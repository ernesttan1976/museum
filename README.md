# National Gallery Mobile App

### Getting Started

https://museumrender.onrender.com/

## Contribution

MIME were a team of four members, with each of us being responsible for different app functionalities and roles. We worked closely with the UI/UX team, K2Z, to develop the app prototype.

[Ernest](https://github.com/ernesttan1976), the GitHub Manager, was responsible for setting up the app environment, configuring the React Material-UI theme, integrating GitHub functionality, and implementing a map search feature.</br>

[Ida](https://github.com/didadeeee), the Scrum Master, utilized [Trello](https://trello.com/invite/b/iE3FX0N4/ATTI2210f3e4c5cad04ab957b63d518ae7e0C5D3A9A5/national-gallery-web) to foster communication and plan the scope around the deadlines. She was responsible for managing the exhibition CRUD functionality.</br>

[May](https://github.com/MayMoeOo95), the Documenter, was responsible for wireframing, collecting sample database, and managing the user & admin login/sign-up and artwork CRUD functionalities.</br>

[Mark](https://github.com/Marklimjr), the Database Manager, was responsible for creating the database model, seeding the data, and implementing the map route feature.</br>

K2Z, a group consisting of three members, [Kally](https://www.linkedin.com/in/kally-chua/), [Kriti](https://www.linkedin.com/in/dr-kriti-krishna/), and [Zhi Qing](http://linkedin.com/in/zhiqingzhao-designer), were primarily responsible for identifying the key UI/UX improvements and designing the app prototype.

## Wireframe

![Home Page Wireframe](/src/images/readme/homepagewireframe.png "Home Page Wireframe")</br>
![Artwork Wireframe](/src/images/readme/artworkwireframe.png "Artwork Wireframe")</br>
![Map Wireframe](/src/images/readme/mapwireframe.png "Map Wireframe")</br>
![Map Route Wireframe](/src/images/readme/routewireframe.png "Map Route Wireframe")</br>

## User Stories

- As a user, I want to read accessible, consistent information on home screen & exhibition detail screen.
- As a logged in user, I want to leave a comment about the exhibition that I joined at National Gallery Singapore.
- As a visitor, I want to improve my wayfinding and exploration of National Gallery Singapore through the map feature.
- As an admin, I want to create, update and delete exhibition and artworks information. </br>

## ERD Diagram (mermaid.live)

[![](https://mermaid.ink/img/pako:eNqNVVFvmzAQ_iuWn9MoJLQNvE0lkyKt29SsD5vycgGHesU2Ohs1LM1_nwmEkOHQgYTgvu989n13x57GKmE0pAwjDimCWEtir_q52L3wDTdcSfL-fnOj9uQTmjeFr5qEZG1dpQEu9ZrW9Igjiyu2PtEXuzxTyNBJ_6Ji6K7difY_9KtbqenPq8UT2dfv1aUNcpkSCYL1jEwAz3rWHLS2ERLSQwrN8EllzUKHU8jOAfqBWQv-4CZjH-GrYjNAiZiOkefV6wBrKbcKBVyyEjCsw1kZQBNZ21XGQiaXeC_OQhosh_YhIB3yPyk7QPmcKYVn_Nvmt620ZUSgKYIB1wclBJNG_yNWWz59qZpFnzFzQVybr64iarzc6jbgTwZ4DXtkCS-EC1Vv-BpxewjtSlLj7hT7knI1zw3eSXKbprbr-mkyZc4ckpwzf12vgbbsdFMzO_qRk3bQOHSvvb6jErnpwVsGpkDmkraB3Prx2JE2LtJ2oXbbnSHY3ziqottJgAglEZAvRXq2qnMm67N0InTvykhHVDArO0_sDD_GW1PzwmwyaTUWE7C5tiPxYHlQGLUqZUxDgwUb0SKvGr2Z-jTcQqatNQf5SylxItlPGu7pjoaeH4zn06k_ncynd77n3Y9oSUN_7AezYFIZ5_7Mm88OI_rn6D8ZB7d-ML-_82-t63TmjagtcKPwsf7hHP87h7-wdRY3?type=png)](https://mermaid.live/edit#pako:eNqNVVFvmzAQ_iuWn9MoJLQNvE0lkyKt29SsD5vycgGHesU2Ohs1LM1_nwmEkOHQgYTgvu989n13x57GKmE0pAwjDimCWEtir_q52L3wDTdcSfL-fnOj9uQTmjeFr5qEZG1dpQEu9ZrW9Igjiyu2PtEXuzxTyNBJ_6Ji6K7difY_9KtbqenPq8UT2dfv1aUNcpkSCYL1jEwAz3rWHLS2ERLSQwrN8EllzUKHU8jOAfqBWQv-4CZjH-GrYjNAiZiOkefV6wBrKbcKBVyyEjCsw1kZQBNZ21XGQiaXeC_OQhosh_YhIB3yPyk7QPmcKYVn_Nvmt620ZUSgKYIB1wclBJNG_yNWWz59qZpFnzFzQVybr64iarzc6jbgTwZ4DXtkCS-EC1Vv-BpxewjtSlLj7hT7knI1zw3eSXKbprbr-mkyZc4ckpwzf12vgbbsdFMzO_qRk3bQOHSvvb6jErnpwVsGpkDmkraB3Prx2JE2LtJ2oXbbnSHY3ziqottJgAglEZAvRXq2qnMm67N0InTvykhHVDArO0_sDD_GW1PzwmwyaTUWE7C5tiPxYHlQGLUqZUxDgwUb0SKvGr2Z-jTcQqatNQf5SylxItlPGu7pjoaeH4zn06k_ncynd77n3Y9oSUN_7AezYFIZ5_7Mm88OI_rn6D8ZB7d-ML-_82-t63TmjagtcKPwsf7hHP87h7-wdRY3)

## Screenshots

### Home

![Home Page Carousell](/src/images/readme/homepagecarousell.png "Home Page Carousell")</br>

### Sign Up

![Sign Up](/src/images/readme/Signup.png "Sign up")</br>

### Login

![Login](/src/images/readme/Login.png "Login")</br>

### Create New Artwork (Admin View)

![Create a New Artwork](/src/images/readme/CreateNewArtwork.png "Create Artwork Form")</br>

### Artworks

![Artworks](/src/images/readme/artworks.png "Artworks")</br>

### Artwork Details

![User Artwork Information](/src/images/readme/UserArtworkInfo.png "User Artwork Information page")</br>

### Artwork Edit & Delete Buttons (Admin View)

![Admin Artwork Information](/src/images/readme/AdminArtworkInfo.png "Admin Artwork Information page")</br>

### Artwork Edit Form (Admin View)

![Edit Artwork](/src/images/readme/AdminEditArtwork.png "Edit Artwork Form")</br>

### Create New Exhibition (Admin View)

![New Exhibition Form](/src/images/readme/newexhibitionform.png "New Exhibition Form")</br>

### Exhibitions

![Exhibition](/src/images/readme/exhibitionaccordion.png "Exhibition")</br>

### Exhibition Details

![Exhibition Page](/src/images/readme/exhibitionpage.png "Exhibition Page")</br>

### Exhibition Artworks & Comments

![Exhibition Artworks & Comments](/src/images/readme/exhibitionartworkcomments.png "Exhibition Artworks & Comments")</br>

### Exhibition Edit Form (Admin View)

![Exhibition Edit Form](/src/images/readme/editexhibitionform.png "Exhibition Edit Form")</br>

### Map Filter

![Map](/src/images/readme/MapFilterPage.png "Maps")</br>

### Map Route

![Map Route](/src/images/readme/MapDirections.png "Map Route")</br>

### Map Explorer

![Map Explorer](/src/images/readme/MapDirectionsExplorer.png "Map Explorer")</br>

## Technologies Used

1. React
2. React Material UI
3. Node.js
4. Express Framework
5. MongoDB & Mongoose
6. JavaScript
7. Render deployment
8. Git & GitHub

## Features

### Login, Sign Up (User & Admin)

- `users-service.js`

```js
export async function signUp(userData) {
  const token = await usersAPI.signUp(userData);
  localStorage.setItem("token", token);
  return getUser();
}

export function getUser() {
  const token = getToken();
  return token ? JSON.parse(window.atob(token?.split(".")[1])).user : null;
}

export function getToken() {
  const token = localStorage.getItem("token");
  if (!token) return null;
  const payload = JSON.parse(window.atob(token.split(".")[1]));
  if (payload.exp < Date.now() / 1000) {
    localStorage.removeItem("token");
    return null;
  }
  return token;
}

export function logout() {
  localStorage.removeItem("token");
}
```

The signUp(userData) function is an asynchronous function that takes a userData object as input. It uses the usersAPI module to make a network request by calling the signUp() function and waiting for the response. The response is a JSON Web Token (JWT), which is stored in local storage using the localStorage.setItem() method. The function then calls getUser() to get the user associated with the token and returns the result.

The getUser() function calls getToken() to obtain the JSON Web Token (JWT). Then uses the token to retrieve the user associated with it. If a token is present, it decodes it and returns the user property of the resulting object. However, if there is no token, it returns null.

The getToken() function retrieves the JSON Web Token (JWT) stored in local storage. If there is no token stored, it returns null. If a token is present, it will decodes it using window.atob() and parses the resulting JSON string to obtain the payload. If the token has expired, as indicated by the exp property in the payload, the function removes the token from local storage and returns null. Otherwise, it returns the token itself.

The logout() function removes the JSON Web Token (JWT) from local storage using the localStorage.removeItem() method.

- `usersController.js`

```js
const create = async (req, res) => {
  const { password } = req.body;
  if (password.length < 5) {
    res
      .status(400)
      .json({ message: "Password is too Short, Please Try Again." });
    return;
  }

  try {
    const user = await User.create(req.body);
    const payload = { user };
    const token = jwt.sign(payload, JWT_SECRET, { expiresIn: 60 }); // 1hr
    res.status(201).json(token);
  } catch (error) {
    res.status(500).json(error);
  }
};

const login = async (req, res) => {
  const { email, password } = req.body;
  if (password.length < 5) {
    res.status(400).json({ message: "Incorrect Password" });
    return;
  }
  try {
    const user = await User.findOne({ email });
    if (user === null) {
      res.status(401).json({ message: "No user found, Please sign up." });
      return;
    }
    const match = await bcrypt.compare(password, user.password);
    if (match) {
      const payload = { user };
      const token = jwt.sign(payload, JWT_SECRET, { expiresIn: 60 });
      res.status(200).json({ token });
      console.log("user login successful");
    } else {
      res.status(401).json({ message: "Wrong password" });
    }
  } catch (error) {
    res.status(500).json(error);
  }
};
```

The create() function firstly checks the length of the password provided in the request body. If it's less than 5 characters/numbers, it responds with a 400 Bad Request status code and a JSON object containing an error message. If the password is long enough, the function tries to create a new user in the database using the User.create() method, passing in the request body as the data to be stored. If the user is created successfully, it creates a payload object containing the user and signs it with a JSON Web Token using the jwt.sign() method. The signed token is then returned in the response with a 201 Created status code. If an error occurs during user creation, such as a database error, it responds with a 500 Internal Server Error status code and returns the error as a JSON object.

The login() function attempts to find a user in the database with the specified email using the User.findOne() method. If the user is not found, it responds with a 401 Unauthorized status code and a JSON object containing a message property with the value "No user found, Please sign up." If a user is found, it compares the password provided in the request body with the user's stored password using the bcrypt.compare() method. If the passwords match, it creates a payload object containing the user and signs it with a JSON Web Token using the jwt.sign() method. The signed token is then returned in the response with a 200 OK status code. If the passwords don't match, it responds with a 401 Unauthorized status code and a JSON object containing a message property with the value "Wrong password." If an error occurs during the login process, such as a database error, it responds with a 500 Internal Server Error status code and returns the error as a JSON object.

- `App.jsx`

```js
...
<Route path="/users/signup" element={<SignUpForm />} />
<Route path="/users/login" element={<LoginForm setUser={setUser} />} />
<Route path="/users/logout" element={<LogOutMsg />} />
...
```

React routes, paths to different components. For example, when a user navigates to "/users/signup" in the application, the <SignUpForm /> component will be rendered.

```js
...
<Route path="/*" element={<AccessDeniedMsg />} />
...
```

If a user navigates to a URL that doesn't match any of the routes defined in the Router component, this AccessDeniedMsg component will be rendered instead.

```js 
...
<Route path="/artworks/new" element={user && user.userRole == "admin" ? <ArtworksNew user={user} /> : <AccessDeniedMsg />} /> 
<Route path="/artworks/:id/edit" element={user && user.userRole == "admin" ? <ArtworksEditForm user={user} /> : <AccessDeniedMsg />} />  
<Route path="/exhibitions/new" element={user && user.userRole == "admin" ? <ExhibitionNew user={user} /> : <AccessDeniedMsg />} /> 
<Route path="/exhibitions/:id/edit" element={user && user.userRole == "admin" ? <ExhibitionUpdate user={user} /> : <AccessDeniedMsg />} /> 
<Route path="/admin/signup" element={user && user.userRole == "admin" ? <AdminSignUpForm user={user} /> : <AccessDeniedMsg />} />   
...
```

The ternary operator is used to conditionally render certain components based on whether the user accessing the site is an admin or not. If the user is an admin, then they are allowed to access certain restricted routes. However, the user is not an admin, it renders an AccessDeniedMsg component, an "Access Denied" message will be shown and prompted the user to log in as an admin.

- `SignUpForm.jsx`

```js
export default function SignUpForm({ setUser }) {
  const [state, setState] = useState({
    name: "",
    email: "",
    password: "",
    confirm: "",
    userRole: "user",
  });
  const [error, setError] = useState("");
  const navigate = useNavigate();

  const disable = state.password !== state.confirm;

  const handleSubmit = (event) => {
    event.preventDefault();
    if (state.password.length < 5) {
      setError("Password must be at least 5 characters or numbers long.");
      return;
    }

    window.alert(
      state.email + " Account has been created successfully. Please Login."
    );
    fetch("/api/users", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(state),
    })
      .then((response) => response.json())
      .then((data) => console.log(data));
    console.log("submitted");
    navigate("/users/login");
  };

  const handleChange = (event) => {
    setState({
      ...state,
      [event.target.name]: event.target.value,
      userRole: "user",
    });
    console.log(state);
  };

  return (
    <Box className="SignUpFormContainer">
      <form
        component="form"
        autoComplete="off"
        onSubmit={handleSubmit}
        className="SignUpForm"
      >
        <Typography variant="h5">Sign Up a new Account </Typography>
        {error}

        <Box className="R1">
          <TextField
            id="outlined-basic"
            label="UserName"
            variant="outlined"
            type="text"
            name="name"
            value={state.name}
            onChange={handleChange}
            required
          />
        </Box>

        <Box className="R1">
          <TextField
            id="outlined-basic"
            label="Email Address"
            variant="outlined"
            type="email"
            name="email"
            value={state.email}
            onChange={handleChange}
            required
          />
        </Box>

        <Box className="R1">
          <TextField
            id="outlined-basic"
            label="Password (min 5)"
            variant="outlined"
            type="password"
            name="password"
            value={state.password}
            onChange={handleChange}
            required
          />
        </Box>

        <Box className="R1">
          <TextField
            id="outlined-basic"
            label="Confirm Password"
            variant="outlined"
            type="password"
            name="confirm"
            value={state.confirm}
            onChange={handleChange}
            required
          />
        </Box>

        <Box className="R1">
          <Button variant="contained" type="submit" disabled={disable}>
            Sign Up
          </Button>
          <p className="error-message">&nbsp;{state.error}</p>
        </Box>

        <Box className="R1">
          <Typography variant="p">
            Already have an account?
            <Link to={`/users/login`}>
              {" "}
              <Button>Login</Button>{" "}
            </Link>
          </Typography>
        </Box>
      </form>
    </Box>
  );
}
```

This sign up form component receives the setUser function as a prop, which is used to update the user state after successful sign up. The state contains the user's name, email, password, and a confirmation of the password. The user role is set as "user" by default. The handleChange() function is used to update the state whenever an input field changes and it’s user role is set as a user by default. The handleSubmit() function is called when the user submits the form. It checks if the password is at least 5 characters/numbers long and if the password and confirm fields match. If these conditions are met, it sends a POST request to the server to create a new user account. If the account is successfully created, it displays an alert message and navigates to the login page. Otherwise, it displays an error message.

- `LoginForm.jsx`

```js
export default function LoginForm({ setUser }) {
  const [error, setError] = useState("");
  const navigate = useNavigate();

  const handleLogin = async (event) => {
    event.preventDefault();
    const formData = new FormData(event.target);
    const body = Object.fromEntries(formData);
    try {
      const response = await fetch("/api/users/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(body),
      });
      const data = await response.json();
      if (data.token) {
        localStorage.setItem("token", data.token);
        setUser(getUser());
        setError("");
        window.alert("Account has login successfully.");
        navigate("/");
      } else {
        setError(data.message);
      }
    } catch (error) {
      setError(error.message);
    }
  };

  return (
    <Box className="LoginFormContainer">
      <form onSubmit={handleLogin} className="LoginForm">
        <br></br>
        <Typography variant="h5">User Login </Typography>
        {error}
        <Box className="R2">
          <TextField
            type="email"
            label="Enter your email address"
            name="email"
            required
          />
        </Box>

        <Box className="R2">
          <TextField
            label="Enter your password"
            name="password"
            type="password"
            required
          />
        </Box>
        <Box className="R2">
          <Button variant="contained" type="submit">
            Login
          </Button>
        </Box>

        <Box className="R2">
          <Typography variant="p">No account yet? </Typography>
          <Link to={`/users/signup`}>
            {" "}
            <Button>Sign Up</Button>{" "}
          </Link>
        </Box>
      </form>
    </Box>
  );
}
```

The LoginForm component is similar to the SignUpForm component, except that it is used for logging in existing users. It also receives a setUser prop and uses the useState hook to manage form state and error messages. It uses the useNavigate hook to navigate between pages after the form is submitted. When the form is submitted, it sends a POST request to the /api/users/login endpoint with the form data. If the response contains a token, it is stored in localStorage and the user is redirected to the homepage. Otherwise, an error message is displayed. Non-existing users can sign up for an account using the link leading to the sign-up page.

### Artwork CRUD

Code extract example will focus on edit and update of Artwork CRUD.

- `artworksController.js`

```js 
const Artwork = require("../models/Artwork");

const create = async (req, res) => {
  try {
    const createdArtwork = await Artwork.create(req.body);
    res.status(200).send(createdArtwork);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};

const index = async (req, res) => {
  try {
    const foundArtwork = await Artwork.find({});
    res.status(200).send(foundArtwork);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};

const deleteArtwork = async (req, res) => {
  try {
    const deletedArtwork = await Artwork.findByIdAndRemove(req.params.id);
    res.status(200).send(deletedArtwork);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};

const show = async (req, res) => {
  try {
    const artwork = await Artwork.findById(req.params.id);
    res.status(200).send(artwork);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};

const update = async (req, res) => {
  try {
    const updatedArtwork = await Artwork.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );
    res.status(200).send(updatedArtwork);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};

module.exports = {
  create,
  index,
  delete: deleteArtwork,
  show,
  update,
};
```
The create() function handles the creation of new artwork by calling the create method on the Artwork model with the request body. If successful, it returns the created artwork with a status code of 200. If there is an error, it returns a status code of 400 and an error message.

The index() function retrieves all artworks by calling the find method on the Artwork model with an empty query. If successful, it returns an array of artworks with a status code of 200. If there is an error, it returns a status code of 400 and an error message.

The deleteArtwork() function handles the deletion of artwork by calling the findByIdAndRemove method on the Artwork model with the artwork ID from the request parameters. If successful, it returns the deleted artwork with a status code of 200. If there is an error, it returns a status code of 400 and an error message.

The show() function retrieves a single artwork by calling the findById method on the Artwork model with the artwork ID from the request parameters. If successful, it returns the artwork with a status code of 200. If there is an error, it returns a status code of 400 and an error message.

The update() function handles the updating of artwork by calling the findByIdAndUpdate method on the Artwork model with the artwork ID from the request parameters and the request body, with { new: true } to return the updated artwork. If successful, it returns the updated artwork with a status code of 200. If there is an error, it returns a status code of 400 and an error message.


- `ArtworksEditForm.jsx`

```js
function ArtworksEditForm({ user }) {
  const { id } = useParams();
  const [artwork, setArtwork] = useState({});
  const navigate = useNavigate();

  useEffect(() => {
    const fetchArtwork = async () => {
      const response = await fetch(`/api/artworks/${id}`);
      const artwork = await response.json();
      setArtwork(artwork);
    };
    fetchArtwork();
  }, [id]);
  const handleChange = (event) => {
    const key = event.target?.name;
    const value = event.target?.value;
    setArtwork({ ...artwork, [key]: value });
  };

  const handleUpdate = async (event) => {
    event.preventDefault();
    const response = await fetch(`/api/artworks/${id}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(artwork),
    });
    navigate("/artworks");
  };

  return (
    <Box
      className="ArtworksEditForm"
      component="form"
      noValidate
      autoComplete="off"
    >
      <FormControl className="EditArtworkForm" autoComplete="off">
        <Typography className="EditArtworks" variant="h4">
          Edit Artworks
        </Typography>

        <TextField
          label="Image URL"
          type="url"
          name="artworkUrl"
          value={artwork.artworkUrl || ""}
          onChange={handleChange}
        />

        <TextField
          label="Artwork Title"
          type="text"
          name="artworkTitle"
          value={artwork.artworkTitle || ""}
          onChange={handleChange}
        />

        <TextField
          label="Artist Name"
          type="text"
          name="artistName"
          value={artwork.artistName || ""}
          onChange={handleChange}
        />

        <TextField
          label="Dimension"
          type="text"
          name="artworkDimension"
          value={artwork.artworkDimension || ""}
          onChange={handleChange}
        />

        <TextField
          label="Information"
          type="text"
          name="artworkInformation"
          value={artwork.artworkInformation || ""}
          onChange={handleChange}
        />

        <TextField
          label="Medium"
          type="text"
          name="artworkMedium"
          value={artwork.artworkMedium || ""}
          onChange={handleChange}
        />

        <TextField
          label="Year"
          type="number"
          name="artworkYear"
          value={artwork.artworkYear || ""}
          onChange={handleChange}
        />

        <TextField
          label="Location"
          type="text"
          name="artworkLocation"
          value={artwork.artworkLocation || ""}
          onChange={handleChange}
        />

        <FormControl fullWidth sx={{ m: 2 }} autoComplete="off">
          <label>Floor</label>
          <Select
            sx={{ width: "200px" }}
            label="Floor"
            name="artworkFloor"
            value={artwork.artworkFloor || ""}
            onChange={handleChange}
          >
            <MenuItem value="" disabled>
              Select Floor
            </MenuItem>
            <MenuItem value="B1">B1</MenuItem>
            <MenuItem value="L1">L1</MenuItem>
            <MenuItem value="L2">L2</MenuItem>
            <MenuItem value="L3">L3</MenuItem>
            <MenuItem value="L4">L4</MenuItem>
            <MenuItem value="L5">L5</MenuItem>
            <MenuItem value="L6">L6</MenuItem>
          </Select>
        </FormControl>

        <Button type="submit" variant="contained" onClick={handleUpdate}>
          Update Artwork
        </Button>
      </FormControl>
    </Box>
  );
}
export default ArtworksEditForm;
```

This Artworks Edit Form component allows the admin to edit an artwork. It receives a user object as a prop and uses the useParams and useNavigate hooks from react-router-dom to get the ID of the artwork and navigate to the artworks page after updating the artwork. The handleChange() function is called when the admin changes the input fields and updates the state with the new values. The handleUpdate() function is used to update the artwork, when the admin clicks the "Update Artwork" button. It sends a PUT request to the backend API with the updated artwork data and navigates to the artworks page.

### Exhibition CRUD

```js
insert your favorite express controller method here
```

```js
insert your favorite react component here
```

### Icon Slider

```js
const IconSlider = () => {
  const BUTTON_LIST = [
    {
      name: "Tickets",
      icon: <ConfirmationNumberIcon />,
      href: "https://www.nationalgallery.sg/admissions",
    },
    {
      name: "Exhibitions",
      icon: <ArtTrackIcon />,
      href: "https://www.nationalgallery.sg/see-do/exhibitions",
    },
    {
      name: "Art Journey",
      icon: <RouteIcon />,
      href: "https://web.nationalgallery.sg/#/art-journeys",
    },
    {
      name: "Tours",
      icon: <SpatialAudioIcon />,
      href: "http://web.nationalgallery.sg/#/search?q%20=&tab=Tours",
    },
    {
      name: "Events",
      icon: <EventIcon />,
      href: "https://www.nationalgallery.sg/whats-on",
    },
    {
      name: "Dining",
      icon: <RestaurantIcon />,
      href: "https://www.nationalgallery.sg/see-do/shopping-and-dining",
    },
    {
      name: "Donate",
      icon: <VolunteerActivismIcon />,
      href: "https://donate.nationalgallery.sg/",
    },
    {
      name: "Contact",
      icon: <AddIcCallIcon />,
      href: "https://www.nationalgallery.sg/about/contact-us",
    },
  ];

  return (
    <Box className="IconSlider">
      <Box className="IconSliderInner">
        {BUTTON_LIST.map((item) => (
          <Stack
            key={item.name}
            direction="column"
            spacing={1}
            alignItems="center"
          >
            <Button
              className="IconButton"
              size="large"
              variant="contained"
              href={item.href}
              startIcon={item.icon}
            />
            <Typography sx={{ fontSize: 10 }} variant="button">
              {item.name}
            </Typography>
          </Stack>
        ))}
      </Box>
    </Box>
  );
};

export default IconSlider;
```

### Map Search

```js
export default function MapPage() {
  const navigate = useNavigate();

  useEffect(() => {
    console.log("Component mounted");
    //this function is in index.html
    setScrollHeight();
  }, []);

  const [locations, setLocations] = useState([]);

  useEffect(() => {
    const fetchLocations = async () => {
      const response = await fetch(`/api/locations`);
      const data = await response.json();
      setLocations(data);
    };
    fetchLocations();
  }, []);

  const [locationsFrom, setLocationsFrom] = useState([]);

  const [locationsTo, setLocationsTo] = useState([]);

  const [formData, setFormData] = useState({
    from: {
      label: "",
      value: "",
    },
    to: {
      label: "",
      value: "",
    },
  });

  const [level, setLevel] = useState("L1");

  const [category, setCategory] = useState("");

  const cat = {
    EXHIBITIONS: "exhibitions",
    ARTWORKS: "artworks",
    "SHOP & DINE": "shopanddine",
    AMENITIES: "amenities",
  };

  function filterLocations() {
    if (!locations) return;

    const filterFloor = locations.filter((item) => item.floor === level);
    if (filterFloor.length === 0) return;

    let result = [
      {
        value: "",
        label: "",
      },
    ];

    if (
      filterFloor[0].exhibitions.length > 0 &&
      (category === "EXHIBITIONS" || category === "")
    ) {
      result.push(
        ...filterFloor[0].exhibitions.map((item) => ({
          value: item._id,
          label: `EXHIBITION ${item.exhibitionTitle}`,
        }))
      );
    }

    if (
      filterFloor[0].artworks.length > 0 &&
      (category === "ARTWORKS" || category === "")
    ) {
      result.push(
        ...filterFloor[0].artworks.map((item) => ({
          value: item._id,
          label: `ARTWORK ${item.artworkTitle}`,
        }))
      );
    }

    if (
      filterFloor[0].shopanddine.length > 0 &&
      (category === "SHOP & DINE" || category === "")
    ) {
      result.push(
        ...filterFloor[0].shopanddine.map((item) => ({
          value: item,
          label: `SHOP & DINE ${item}`,
        }))
      );
    }

    if (
      filterFloor[0].amenities.length > 0 &&
      (category === "AMENITIES" || category === "")
    ) {
      result.push(
        ...filterFloor[0].amenities.map((item) => ({
          value: item,
          label: `AMENITIES ${item}`,
        }))
      );
    }

    if (result.length > 0) {
      setLocationsFrom(result);
      setLocationsTo(result);
    }
  }

  const handleLevel = (event, newLevel) => {
    console.log("Level:", newLevel);
    setLevel(newLevel);
    filterLocations();
  };

  const handleCategory = (event, newCategory) => {
    console.log("Category:", newCategory);
    setCategory(newCategory);
    filterLocations();
  };

  function handleChange(event, values, field) {
    //field = 'from' or 'to'
    console.log(field, ":", values);
    setFormData({
      ...formData,
      [field]: values,
    });
    console.log(formData);
  }

  useEffect(() => {
    if (
      formData.from.value !== "" &&
      formData.from.value === formData.to.value
    ) {
      const newLocationsTo = locationsTo.filter(
        (item) => item.value !== formData.from.value
      );
      setLocationsTo(newLocationsTo);
      const newFormData = { ...formData, to: { value: "", label: "" } };
      setFormData(newFormData);
    }
  }, [formData]);

  function handleSubmit(event) {
    event.preventDefault();
    console.log("Submit: ", formData);
    navigate(
      `/map/directions/from/${formData.from.value}/to/${formData.to.value}`
    );
  }

  useEffect(() => {
    filterLocations();
  }, [level, category, locations]);

  return (
    <Box className="MapPage1">
      <Box
        className="MapPageForm1"
        onSubmit={handleSubmit}
        component="form"
        sx={{ "& .MuiTextField-root": { m: 1 } }}
        noValidate
        autoComplete="off"
      >
        <div className="MapFormTopRow1">
          <Button className="LeftButton1">
            <RadioButtonCheckedIcon />
          </Button>
          <Autocomplete
            className="MapFormTextField1"
            sx={{ fontSize: "12px", minWidth: "150px" }}
            value={formData.from}
            size="small"
            margin="dense"
            placeholder="Enter where you are"
            disablePortal
            options={locationsFrom}
            onChange={(event, values) => handleChange(event, values, "from")}
            isOptionEqualToValue={(option, currentValue) => {
              if (currentValue === "") return true;
              return option.name === currentValue.name;
            }}
            renderInput={(params) => (
              <TextField {...params} name="from" label="From" />
            )}
          />
          <Button className="RightButton1">
            <SwapVertIcon />
          </Button>
        </div>
        <div className="MapFormBottomRow1">
          <Button className="LeftButton1">
            <FmdGoodIcon />
          </Button>
          <Autocomplete
            className="MapFormTextField1"
            sx={{ fontSize: "12px", minWidth: "150px" }}
            value={formData.to}
            size="small"
            margin="dense"
            placeholder="Enter destination"
            disablePortal
            options={locationsTo}
            onChange={(event, values) => handleChange(event, values, "to")}
            isOptionEqualToValue={(option, currentValue) => {
              if (currentValue === "") return true;
              return option.name === currentValue.name;
            }}
            renderInput={(params) => (
              <TextField {...params} name="to" label="To" />
            )}
          />
          <Button className="RightButton1" type="submit">
            <DirectionsWalkRoundedIcon />
          </Button>
        </div>
      </Box>
      <ToggleButtonGroup
        className="LevelButtonGroup1"
        value={level}
        exclusive
        onChange={(ev, value) => handleLevel(ev, value)}
        aria-label="level"
      >
        <ToggleButton value="B1" aria-label="B1">
          B1
        </ToggleButton>
        <ToggleButton value="L1" aria-label="L1">
          L1
        </ToggleButton>
        <ToggleButton value="L2" aria-label="L2">
          L2
        </ToggleButton>
        <ToggleButton value="L3" aria-label="L3">
          L3
        </ToggleButton>
        <ToggleButton value="L4" aria-label="L4">
          L4
        </ToggleButton>
        <ToggleButton value="L5" aria-label="L5">
          L5
        </ToggleButton>
        <ToggleButton value="L6" aria-label="L6">
          L6
        </ToggleButton>
      </ToggleButtonGroup>
      <ToggleButtonGroup
        className="CategoryButtonGroup1"
        value={category}
        exclusive
        onChange={handleCategory}
        aria-label="category"
      >
        <ToggleButton value="EXHIBITIONS" aria-label="Exhibitions">
          EXHIBITIONS
        </ToggleButton>
        <ToggleButton value="ARTWORKS" aria-label="Artworks">
          ARTWORKS
        </ToggleButton>
        <ToggleButton value="SHOP & DINE" aria-label="Shop & Dine">
          SHOP & DINE
        </ToggleButton>
        <ToggleButton value="AMENITIES" aria-label="Amenities">
          AMENITIES
        </ToggleButton>
      </ToggleButtonGroup>

      <Box className="MapComponent1">
        <MapComponent level={level} />
      </Box>
    </Box>
  );
}
```

### Map Route

The controller holds the logic of taking in the "to and from" from the map page and generating a pre-written route from the database. The controller pulls in the ObjectID of the respective exhibitions and runs it in an If Else statement to respond with the ObjectID of a route solution. Using req.params the objectIDs are retrieved from the URL from the :from and :to and passed through as arguements for the function findRoute.

The current working examples of the route are:

1. EXHIBITION Between Declarations and Dreams L1 to EXHIBITION Siapa Nama Kamu B1
2. EXHIBITION Between Declarations and Dreams L2 to EXHIBITION As We See It L3

- `directionsController.jsx`

```js
const Directions = require("../models/Directions");
require("../models/Explorer");

const show = async (req, res) => {
  try {
    const from = req.params.from;
    const to = req.params.to;

    function findRoute(from, to) {
      if (
        from === "6425c260c9d195369ec02476" &&
        to === "6425c854c9d195369ec02494"
      ) {
        result = {
          fromMapUrl: "EXHIBITION Between Declarations and Dreams L1",
          toMapUrl: "EXHIBITION Siapa Nama Kamu B1",
          steps: "642bb5bf350c1b20a4cdb627", // Object ID of Route A
        };
      } else if (
        from === "6425c260c9d195369ec02476" &&
        to === "6430ab5e625b2ad2b95f96ab"
      ) {
        result = {
          fromMapUrl: "EXHIBITION Between Declarations and Dreams L2",
          toMapUrl: "EXHIBITION As We See It L3",
          steps: "642e2ff3e64813ab8c55a0ca", // Object ID of Route B
        };
      } else {
        result = {
          steps: "64305ed5cf61dfb8fdd221cc",
        };
      }

      return result;
    }

    const routeAnswer = findRoute(from, to).steps;

    console.log("this result " + routeAnswer);

    const foundDirections = await Directions.findById(routeAnswer).populate(
      "routeDirections"
    );
    res.status(200).json(foundDirections);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
};

module.exports = {
  show,
};
```

The MapDirectionsExplorer is a child component of the Map Directions Route Page. It receives data from the database that holds the route information. For this component it has the props required to fill the table with Icons, a string of directions in text and an img URL for the route path. The data representing the icon in the database comes in a value of a Keyname such as "turnRight". An object "const Icons" contains a key value pair of the keyname and the Icon componenet from MUI. Therefore when the keyname is called into the table, "[Icons.turnRight]" will access the turnRight Key in the Icons object and access the value of the MUI Icon Component.

- `MapDirectionsExplorer.jsx`

```js
const Icons = {
  turnRight: <TurnRightOutlinedIcon />,
  turnLeft: <TurnLeftOutlinedIcon />,
  slightRight: <TurnSlightRightOutlinedIcon />,
  slightLeft: <TurnSlightLeftOutlinedIcon />,
  goStraight: <StraightOutlinedIcon />,

  stairs: <StairsOutlinedIcon />,
  camera: <CameraAltOutlinedIcon />,
  artwork: <PhotoOutlinedIcon />,
};

export default function BasicTable(props) {
  const { direction, table } = props;

  const { id } = useParams();
  const [tableData, setTableData] = useState([]);

  return (
    <>
      <Typography>Explorer Mode - on</Typography>
      <TableContainer style={{ width: "100%" }} component={Paper}>
        <Table sx={{ minWidth: 400 }} aria-label="simple table">
          <TableHead>
            <TableRow>
              <TableCell align="center">Direction icon </TableCell>
              <TableCell align="center">Directions</TableCell>
              <TableCell align="center">Img</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {table?.map((table, index) => (
              <TableRow
                key={index}
                //   sx={{ '&:last-child td, &:last-child th': { border: 0 } }}
              >
                <TableCell align="center" component="th" scope="row">
                  {Icons[table.icon]}
                </TableCell>
                <TableCell align="center">
                  {table.directions}
                  {table.explorerPrompt}
                  <a href={`${table.featureUrl}`}>{table.featureTitle}</a>
                </TableCell>
                <TableCell align="center">
                  <img src={`${table.imgUrl}`} height="150" />{" "}
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </>
  );
}
```

### Client Side Routing

```js
<Routes>
  <Route path="/*" element={<PageNotFound />} />
  <Route path="/" element={<HomePage user={user} />} />
  <Route path="/users/signup" element={<SignUpForm />} />
  <Route path="/users/login" element={<LoginForm setUser={setUser} />} />
  <Route path="/users/logout" element={<LogOutMsg />} />
  <Route path="/artworks" element={<ArtworksPage />} />
  <Route path="/artworks/:id" element={<ArtworkInfo user={user} />} />{" "}
  <Route path="/exhibitions/:id" element={<ExhibitionPage user={user} />}></Route>{" "}
  <Route path="/experimental" element={<ExperimentalPage />} />
  <Route path="/map" element={<MapPage />} />
  <Route path="/map/directions" element={<MapPage2 />} />
  <Route path="/map/directions/from/:from/to/:to" element={<MapPage2 />} />
  ///map/directions?to=1234from=5678 //get request, post to req.query
  <Route
    path="/artworks/new"
    element={
      user && user.userRole == "admin" ? (
        <ArtworksNew user={user} />
      ) : (
        <AccessDeniedMsg />
      )
    }
  />
  <Route
    path="/artworks/:id/edit"
    element={
      user && user.userRole == "admin" ? (
        <ArtworksEditForm user={user} />
      ) : (
        <AccessDeniedMsg />
      )
    }
  />
  <Route
    path="/exhibitions/new"
    element={
      user && user.userRole == "admin" ? (
        <ExhibitionNew user={user} />
      ) : (
        <AccessDeniedMsg />
      )
    }
  />
  <Route
    path="/exhibitions/:id/edit"
    element={
      user && user.userRole == "admin" ? (
        <ExhibitionUpdate user={user} />
      ) : (
        <AccessDeniedMsg />
      )
    }
  />
  <Route
    path="/admin/signup"
    element={
      user && user.userRole == "admin" ? (
        <AdminSignUpForm user={user} />
      ) : (
        <AccessDeniedMsg />
      )
    }
  />
</Routes>
```

## Conclusion

### Biggest Challenge

Ernest:

- Identifying the need for an industrial grade UI framework. Selecting and learning Material UI framework early in the project helped to allieviate most of the issues and reduced risk of delays.
- Splitting the coding responsibilities to avoid double work and clashes.
- Clarifying the scope of work with the UI/UX team helped to reduce the guesswork and speed up the development.
- Deployment was tricky because the host servers did not provide enough documentation and troubleshooting advice for free account users. Cyclic server had a disk limit of 240mb, which our deployment exceeded because of the large MUI packages. Render server was using [Node 14](https://render.com/docs/node-version), which was not surfaced up by the error logs but was hidden inside the documentation.
  </br>

Ida:

- Material UI CSS Style Default Behaviour
- Learning to work in a group using Github
- Managing expectations
- Communicate each other's code
  </br>

May:

- Material UI
- Understanding each other's style of code.
- The use of bcrypt and jsonwebtoken.
- Getting the artwork Information to show when user click on the artwork.
  </br>

Mark:

- Working in the MUI environment
- Initial modelling of Data Models and planning out relationships and dependencies
- Formulating the logic of a map feature
- Condensing a route solution into a single object that holds various fields of information, eg img,directions,features,icons
  </br>

### Key Learnings

Ernest:

- The power of JSX enables you to output HTML within the Javascript. Enabling you to output an icon component with an array like this.
  i.e. The value of a property can be a JSX element.

```
const userMenuItems = [
    {
      text: "Home",
      to: "/",
      icon: <HomeOutlinedIcon />,
    },
    {
      text: "Exhibition",
      to: "/",
      icon: <ArtTrackIcon />,
    },
    {
      text: "Artworks",
      to: "/artworks",
      icon: <ImageSearchOutlinedIcon />,
    },
    {
      text: "Map",
      to: "/map",
      icon: <LocationOnOutlinedIcon />,
    },
  ];
```

</br>

Ida:

- Group Git
- Learnt debugging skills from fellow members
- Material UI - Difficult at first but very powerful tool
- Utilising wireframing, trello to manage a group project
- Model is CRUCIAL
  </br>

May:

- The use of Group Git, branches and conflicts during merge.
- Initial planning of the project (wireframes, model schemas, paths and routes), the more detailed the planning, result in a clearer and smoother implementation of the app.
- It is important to aim and focus on completing one specific task at a time.
- React CRUD.
- User Sign up and Login using bcrypt and jsonwebtoken.
- Utilization of ternary operator to enable certain user to accessible to certain informations.
  </br>

Mark:

- Error finding through learning to read DevTools and testing routes with Insomnia
- Understanding how to work in an environment where there are potential conflicts in code and resolving it by using a common seed data from the start
- Planning the code with the MUI structure
  </br>

## Why We Choose React?

Based on this analysis, we can conclude that React is a popular choice due to its high job demand(1), ease of learning(2), component-based architecture(5), virtual DOM(4), reactive updates(8), and state management (Redux)(14). React also offers excellent performance (10), simplicity(11), and optional support for Typescript (12), making it suitable for building complex web applications. Additionally, React's mobile framework, React-Native (13), makes it an excellent choice for building mobile apps.

However, React does not offer native support for server-side rendering (15), forms(17), routing(16), CSS utilities(18), UI Component Libraries(19), but these functionalities can be added using third-party libraries such as Next.js, Formik, React Router, Tailwind CSS and Material UI, respectively.

Ultimately, the choice of technology depends on the specific requirements of the project, and we should consider factors such as community support, documentation, and compatibility with existing code. Nonetheless, React's popularity and vast ecosystem make it a solid choice for building modern web applications.

| React Features              | React          | Vanilla JS  | EJS Templates | Angular                | Vue             |
| --------------------------- | -------------- | ----------- | ------------- | ---------------------- | --------------- |
| (1) Job Demand              | 57%            | N/A         | N/A           | 31%                    | 11%             |
| (2) Ease of Learning        | ★★★★★          | ★★★★★       | ★★★           | ★★★                    | ★★★★★           |
| (3) Declarative             | Yes            | N/A         | N/A           | Imperative             | Yes             |
| (4) One-way data binding    | ★★★★★          | N/A         | N/A           | 2-way                  | 2-way           |
| (5) Component-Based         | ★★★★★          | N/A         | N/A           | ★★★★★                  | ★★★★            |
| (6) Virtual DOM             | Yes            | N/A         | N/A           | Direct DOM             | Yes             |
| (7) JSX Syntax              | Yes            | N/A         | EJS Syntax    | Template Syntax        | Template Syntax |
| (8) Reactive Updates        | ★★★★★          | N/A         | N/A           | ★★★★                   | ★★★★            |
| (9) Dependency Injection    | ★★★★★          | N/A         | N/A           | ★★★★                   | ★★              |
| (10) Performance            | ★★★★★          | ★★★★        | ★★★           | ★★★★                   | ★★★             |
| (11) Simplicity             | ★★★★★          | ★★★★        | ★★★           | ★★★                    | ★★★★            |
| (12) Typescript             | Optional       | N/A         | N/A           | Tightly integrated     | Optional        |
| (13) Mobile Framework       | (React-Native) | N/A         | N/A           | NativeScript           | Weex            |
| (14) State Management       | (Redux)        | N/A         | N/A           | (NgRx)                 | (Vuex)          |
| (15) Server-Side Rendering  | (Next.js)      | N/A         | ★★★★          | (Angular Universal)    | N/A             |
| (16) Routing                | (React Router) | N/A         | N/A           | (Angular Router)       | (Vue Router)    |
| (17) Forms                  | (Formik)       | N/A         | N/A           | (Angular Forms)        | (Vee-Validate)  |
| (18) CSS Utilities          | (Tailwind CSS) | (Bootstrap) | N/A           | (Angular Material)     | (Vuetify)       |
| (19) UI Component Libraries | (Material UI)  | N/A         | N/A           | (PrimeNG)(Material UI) | (Element UI)    |

Notes:

- The ratings are represented by stars (★), with 5 stars being the highest rating.
- Some of the features are not applicable for certain frameworks (represented as N/A).
- The external libraries are listed in brackets in the column cells.

## Why Material UI

Material UI is one of the most popular React UI frameworks and well documented. It is easy to create beautiful, responsive user interfaces.
It has a wide range of components available. Its powerful theming system gives it a consistent look and feel. It is sort of an industrial standard.
Teams can expect to have higher productivity when utilizing Material UI because many components work out of the box.

Downsides to Material UI. The look and feel is similar to other Material UI sites. CSS is tightly controlled by the MUI system and tricky to customize.
Overkill for small projects. Large bloated file size and perceived to be slow.

It may be possible to use the ['headless' MUI system](https://mui.com/blog/introducing-mui-base/) to more deeply customize the look and feel of MUI.

## Why Node.js / Express / MongoDB (MERN Stack)

The **_MERN stack_** is using Javascript on both frontend and backend, making it cost effective to hire only Javascript developers for the project. Context switching is minimized thus improving productivity.

**_Node.js_** is fast and scalable. Non-blocking single threaded IO event loop. Unlike Java, Node.js has no need for complex concurrent multi-threaded code, it's single threaded code is easier to comprehend.

**_MongoDB and its ODM Mongoose_** is very close to using JSON objects in Javascript. Thus it is easy to manipulate and query the data. MongoDB is suitable for web projects that have highly variable and unstructured data that otherwise will be restricted by SQL schemas.

**_Express_** is a defacto lightweight, performant and unopinionated Node.js web framework.

## Resources

Product Prototype: <a href="https://www.figma.com/proto/WZ6XPMR2mlYvRAr9kvNFpD/P3-Gallery-Explorer-Redesign-v3.0?node-id=1-2&starting-point-node-id=1%3A2&scaling=scale-down">Figma</a><br />
Wireframe: <a href="https://docs.google.com/presentation/d/1QK74u5tYnI7stAfgfH9_ZuHCs52L_hfNjI2NLIp1Txw/edit?usp=sharing">Google Docs</a><br />
Project Management: <a href="https://trello.com/invite/b/iE3FX0N4/ATTI2210f3e4c5cad04ab957b63d518ae7e0C5D3A9A5/national-gallery-web">Trello</a><br />
Path & Components: <a href="https://docs.google.com/presentation/d/1zn3BJGd09h5cBunKGQARrrkWUGV-Zak4PTxHN-Otd1w/edit?usp=sharing">Google Docs</a><br />
Photos used: <a href="https://pixabay.com/">pixabay</a><br />
Artworks and Exhibitions Reference: <a href="https://www.nationalgallery.sg/">National Gallery Singapore</a>
